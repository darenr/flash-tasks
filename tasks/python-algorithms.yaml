tasks:
  - heading: |
      Memoized Fibonacci Sequence
    description: |
      This algorithm calculates the nth Fibonacci number efficiently
      by storing (memoizing) previously computed values. It avoids redundant
      calculations inherent in a naive recursive approach, drastically
      improving performance for larger `n` values.

      ```python
      def memoized_fib(n, memo={}):
          if n in memo:
              return memo[n]
          if n <= 1:
              return n
          
          memo[n] = memoized_fib(n - 1, memo) + memoized_fib(n - 2, memo)
          return memo[n]

      # Example usage:
      # print(memoized_fib(10)) # Output: 55
      # print(memoized_fib(50)) # Computes quickly!
      ```
      **Key Concept**: Dynamic Programming, specifically top-down memoization.
  - heading: |
      Two-Pointer Algorithm for Sorted Array
    description: |
      A common pattern for solving problems involving sorted arrays. This example
      finds if there's a pair of numbers in a sorted array that sums up to a
      target value. It uses two pointers, one starting from the beginning and
      one from the end, moving them inwards based on the current sum.

      ```python
      def find_pair_with_sum(arr, target_sum):
          left, right = 0, len(arr) - 1
          while left < right:
              current_sum = arr[left] + arr[right]
              if current_sum == target_sum:
                  return True # Or return (arr[left], arr[right])
              elif current_sum < target_sum:
                  left += 1
              else: # current_sum > target_sum
                  right -= 1
          return False

      # Example usage:
      # arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
      # print(find_pair_with_sum(arr, 15)) # Output: True (e.g., 6+9 or 7+8)
      # print(find_pair_with_sum(arr, 19)) # Output: False
      ```
      **Efficiency**: O(n) time complexity, significantly better than O(n^2) for many problems.
  - heading: |
      Prime Number Generator (using `yield`)
    description: |
      This generator function yields prime numbers up to a given limit `n`
      using a variation of the Sieve of Eratosthenes. The `yield` keyword
      makes it memory efficient, generating primes on-the-fly without
      storing all of them in memory simultaneously.

      ```python
      def primes_generator(limit):
          if limit < 2:
              return
          is_prime = [True] * (limit + 1)
          is_prime[0] = is_prime[1] = False
          
          for p in range(2, int(limit**0.5) + 1):
              if is_prime[p]:
                  for multiple in range(p*p, limit + 1, p):
                      is_prime[multiple] = False
          
          for p in range(2, limit + 1):
              if is_prime[p]:
                  yield p

      # Example usage:
      # for prime in primes_generator(20):
      #     print(prime, end=' ') # Output: 2 3 5 7 11 13 17 19
      ```
      **Pythonic Feature**: Demonstrates effective use of `yield` for creating iterators.
  - heading: |
      Function Timing Decorator
    description: |
      Decorators allow you to wrap functions, modifying their behavior. This
      decorator measures the execution time of any function it decorates.
      It's a powerful way to add cross-cutting concerns (like logging, timing,
      authentication) to multiple functions without repeating code.

      ```python
      import time

      def timer_decorator(func):
          def wrapper(*args, **kwargs):
              start_time = time.perf_counter()
              result = func(*args, **kwargs)
              end_time = time.perf_counter()
              print(f"Function '{func.__name__}' took {end_time - start_time:.4f} seconds to run.")
              return result
          return wrapper

      @timer_decorator
      def long_running_function(n):
          total = 0
          for _ in range(n):
              total += sum(range(1000))
          return total

      # Example usage:
      # _ = long_running_function(100)
      # # Expected Output: Function 'long_running_function' took X.XXXX seconds to run.
      ```
      **Pythonic Feature**: Excellent illustration of decorators (`@`) for code modification.
  - heading: |
      Custom Context Manager for Resource Handling
    description: |
      Context managers (used with the `with` statement) ensure that resources
      are properly acquired and released, even if errors occur. This example
      creates a custom context manager for a 'resource' that needs setup
      and teardown, similar to how file handling or database connections work.

      ```python
      class ManagedResource:
          def __init__(self, name):
              self.name = name
              print(f"Resource '{self.name}' initialized.")

          def __enter__(self):
              print(f"Resource '{self.name}' acquired for use.")
              return self # Return self to be assigned to 'as' variable

          def __exit__(self, exc_type, exc_val, exc_tb):
              if exc_type:
                  print(f"An error of type {exc_type.__name__} occurred: {exc_val}")
              print(f"Resource '{self.name}' released.")
              # Return False to propagate the exception, True to suppress it
              return False

      # Example usage:
      # with ManagedResource("database_connection") as db:
      #     print(f"Working with {db.name}...")
      #     # Simulate an error by uncommenting next line
      #     # raise ValueError("Something went wrong inside the context!")
      #
      # print("Outside the with block.")
      ```
      **Pythonic Feature**: Demonstrates `__enter__` and `__exit__` methods for custom `with` statement support.